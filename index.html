<!doctype html>
<html lang="en-US">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <link rel="stylesheet" href="motherduck.css" />
  
  <title>Motherduck Landing Strip</title>
</head>



<body bgcolor="#BBBB66">

<header>
<h1 id="title">C Suppliments For Taking Over the World! </h1>



<object type="text/html" data="./navigation.html" style=" width:90vw; height:5em"> </object>


<p><mark>
<strong>Nov.2017 &mdash; </strong>
Marin is building a collaboration library and Nathan has yet to complete Euler Project #2 challenge.</mark>
</p>


<blockquote>
"Don't quote any of this shit." 
</blockquote>
<cite>&mdash;Motherduck</cite>

</header>



<main>

<hr />


<section>
<h2>Who We Are </h2>


<figure class="pics">
  <span class="dual">
    <img src="./Player1.jpg" alt="Player 1 mugshot" class="profile" />
    <img src="./Player2.jpg" alt="Player 2 mugshot" class="profile" />
  </span>
  <span class="dual">
    <img src="./Player3.jpg" alt="Player 3 mugshot" class="profile" />
    <img src="./player4.jpg" alt="Player 4 mugshot" class="profile" />
  </span>
  
  <figcaption> Familiar Faces </figcaption>
</figure>


<blockquote>
"Learning the language's syntax is <em>trivial</em>. <br />
Actually <em>making use</em> of the language is elusive." 
</blockquote>
<cite>&mdash;Motherduck</cite>


<p>
We are <em>amateurs</em> and fanatic about details; fascinated to know what's <em>really</em> happening under the hood while remaining practical and to be in absolute control in our programming.  Why accept limited powers?
</p>


<blockquote>
"Do not trust abstracted languages!" 
<br /><br />
"We're not stringing together APIs, here, and calling it programming."
</blockquote>
<cite>&mdash;Motherduck</cite>


<h3>Get Your Own Red Pill </h3>

<ul>
  <li><a href="https://www.meetup.com/cities/ca/bc/vancouver/">Meetup</a>, Vancouver </li>
  <li>Email: [copyright owner at bottom] at this domain, SUBJECT=[opposing pill color, 2 or less words only], or forever hold your peace.  Initially: plain text, no links.
  <li>We have a VPN for remote collaboration. </li>
  <li>This page is still just <em>thinking-out-loud</em>.  Do not call us.  We'll call you. </li>
</ul>

</section>



<br /><br /><hr />



<section>
<h2>Why Love C </h2>


<p>
C is <em>lingua franca</em>.  The Godfather.  C expects one to make system calls because, instead, it was around before gimmicks started being made, and it uses intuitive paradigms to real problem-solvers.  There are no excuses for there "not being a library for that yet."  You will find that most language runtimes are merely built atop C, waiting for capabilities to be written in C.  <em>What-a-shit-show</em>.
</p>  


<blockquote>
"Pity the fool who says it cannot be done in C!" 
</blockquote>
<cite>&mdash;Motherduck</cite>


<p>
C is the go-to <em>foundation</em> for real engineers developing new technology, making it ubiquitous within the tools one uses today.  Its runtime is designed to run on metal&mdash;<em>all of it</em>.  How the C runtime implements ideas is how UNIX &ndash;and subsequently, POSIX&ndash; systems as-a-whole get implemented (Internet servers, financial systems, all mobile devices, many more!)  The two technologies were developed in tandom and have been in bed together ever since.  Competing languages will try to compare, but C is the veteran in the room that has built it all.
</p>
<P>
Micro-managing code to optimize algorithms makes C binaries the fastest practical processes [<a href="https://benchmarksgame.alioth.debian.org/u64q/which-programs-are-fastest.html">benchmarks</a>].  Being just a step above Assembly, it is expressive as a high level language, while having the ability to cater to the hardware.  This is why kernels are made with C.  The real power goes to those with the faculties to master its domain, as one is made responsible for the binaries of which they produce.  The training wheels are off and there is no safety net!  (Not true anymore, the OS has many built-in fail-safes.)  There are no cutting corners, it demands thoroughness.  Use it wisely.  The first principle in the "spirit of C" is to <em>trust the programmer</em>.
</p>

<blockquote>
"If you can C, everything else is cheese." 
</blockquote>
<cite>&mdash;Motherduck</cite>
</section>



<br /><br /><hr />
<a href="#title" class="top">^top</a>



<section>
<h2>The Low Down </h2>

<h3>What distinguishes C? </h3>
<ul>
  <li>C compiles to machine code </li>
  <li>Manual memory management </li>
  <li>No garbage collection </li>
  <li>Minimal tools built-in; streamlined </li>
  <li>Not portable (despite early claims compared to Assembly upon inception) </li>
  <li>Is <em>in fact</em> a high level language
  <li>Often <em>is</em> the runtime system </li>
</ul>


<h3>The Contenders</h3>

<ul>
  <li><em>C++</em> is its own beast.  Originally as a superset to C for OOP extensions, it has deviated from C, though ANSI-C code will still compile on a C++ compiler.  C++ is very suitable for large projects with its OOP design.  It does, however, suffer from identity insecurities because it is always trying to stance-up against C for some reason. </li>
  <li><em>Objective-C</em> is a direct superset of C adopted by Apple for their products, now superceded by Swift.  C code will always compile on Objective-C.  Learn C, and Objective-C will be a breeze.  </li>
  <li><em>C#</em> (C-Sharp) has a similar relation to C as C++, and is developed by Microsoft for their products as part of thier .NET framework.  It mostly compiles to Common Intermediate Language (CIL) for a Common Language Infrastructure/Runtime (CLI, CLR).  C# is also the scripting language for the Unity game engine.</li>
</ul>

<p>
Both Microsoft and Apple kernels are originally &ndash;and still contain&ndash; C code.
</p>


<h3>When and how to C </h3>

<blockquote>
"C should not be your first rodeo."
</blockquote>
<cite>&mdash;Motherduck</cite>

<p>
The distinguishing factors of C make it appropriate for projects with low level considerations of systems, and reduntant otherwise.  If one is not going to enjoy venturing into the abyss of systems, there are perfectly suited languages for that purpose of which to spend one's time.  Do not let tutorials cop-out and convince oneself that C is just syntax like most other languages; its minimalist runtime system is not going to hold your hand.  Writing robust battle-ready code for production and showcasing is going to require a broader understanding of the toolchain than just that of the C language itself.  Requiring a compatibility layer like Cygwin/MinGW is the antithesis of being a C programmer.  This is where the programmers are distinguished from the script-kiddies.
</p><p>
Reading a C-standard textbook from cover to index will fill one's head with un-applicable knowledge.  Unbuffered keyboard input from the user is not acquired through the C language alone, never mind audio/visual and device communications.  (And static programs won't get one laid.)  Once one breaks those barriers the code will &ndash;initially&ndash; only be valid within the environment of which it was produced.  Fuck.
</p><p>
Start with the preprocessor and the linker&mdash;learn the toolchain!  It's unsexy but there's no point in learning C if one is not going to master its domain.  To master a domain, one must work from the ground&ndash;up.  Learn the preprocessor and the linker, be a programmer!
</p>

<blockquote>
"If you want to be a script-kittie, stay in college."
</blockquote>

<blockquote>
"If you are a person who already enjoys boring subjects like mathematics, biology or chemistry, then you've found another home in computer science with C!"
</blockquote>
<cite>&mdash;Motherduck</cite>

</section>



<br /><br /><hr />
<a href="#title" class="top">^top</a>



<section>
<h2>Terms you may learn : </h2>
  
<p>
(but not all necessary for fun)
</p>


<h3>C-Specific </h3>

[<a href="" onclick="expandAll(C)">Expand</a> all | 
 <a href="" onclick="collapseAll(C)">Collapse</a> all]

<br /><br />

<details>
  <summary>Assembler, Linker, Preprocessor </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Atomic, pthread </summary>
  <p>
  Description
  </p>
</details>
  
<details>
  <summary>ANSI-C </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Clean Code, Secure Coding, SEI-CERT </summary>
  <p>
  Description
  </p>
</details>
  
<details>
  <summary>crt0 </summary>
  <p>
  Description
  </p>
</details>
  
<details>
  <summary>GCC, LLVM/Clang </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>GMP, GNU MPFR </summary>
  <p>
  Description
  </p>
</details>
  
<details>
  <summary>libc (by GNU, Musl, or Bionic..) </summary>
  <p>
  Description
  </p>
</details>
  


<!-- ******************************************** -->
<h3>POSIX Land (Linux, MacOS..)</h3>
<!-- ******************************************** -->

<details>
  <summary>Cygwin, MinGW </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>ncurses </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>POSIX, SUS </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>SIGINT, SIGKILL </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Socket </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>/dev/urandom </summary>
  <p>
  Description
  </p>
</details>


<!-- ******************************************** -->
<h3>General Programming </h3> 
<!-- ******************************************** -->

<details>
  <summary>Algorithms, (Big) O-Notation, P vs NP </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>ALU/FPU (IEEE 754), SSE </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>ASCII, UTF/Unicode </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>BSD-(n)Clause, GNU, GPL, MIT </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>BLAS, LAPACK </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Cache, Register </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary><a href="./structures.html">Data Structures</a> </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Declarative, Functional, Imperative, Paradigms, Object-Oriented (OOP) </summary>
  <p>
  <em>Functional</em> programming is just <em>imperative</em> under the hood.
  </p>
</details>

<details>
  <summary>DWARF, ELF </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Endianness - Big/Little </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Entropy </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>GNU Make, Makefile </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>GPGPU, OpenGL, OpenCL, Cuda </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Kernel </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>MMU, Virtual Addressing </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>OpenACC, OpenMP, OpenMPI </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Race condition, Stack Overflow </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Shared Object, Dynamic/Static Linking </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Stack, Heap </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Strong/Weak Typing </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>TCP, UDP </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Toolchain </summary>
  <p>
  Description
  </p>
</details>

<details>
  <summary>Two's Compliment </summary>
  <p>
  Description
  </p>
</details>

<h3>Reserved Just For You </h3>

<details>
  <summary>Segmentation Fault </summary>
  <p>
  Learn to love it.
  </p>
</details>


</section>



<br /><br /><hr />



</main>
<footer> &copy; 2017 eccnate (on Github.com). All rights reserved. </footer>



</body>
</html>

<!doctype html>
<html>
<body bgcolor="#BBBB66">

<center><h1>
  C-to-C
</h>
  <hr>
  <h6>
    Familiar Faces :)
  </h6>
  <img src="./Player1.jpg" height="225" width="225" />
  <img src="./Player2.jpg" height="225" width="225" />
  <img src="./Player3.jpg" height="225" width="225" />
  <br />
  Amateur strangers in Vancouver starting with C on Linux.
 </center>
 
  <br />
  <br />
<details>
<summary><b>
  Why We Love C?
  </b></summary>

  <p>We're nerds who care about details, fascinated to know what's <b><i>really</i></b> happening under the hood, and to be in absolute control in our programming!  (Do not trust abstracted languages!)  How the C standard implements ideas, is how the Linux computer and Internet servers as-a-whole get implemented. (..And Android phones, and Chrome Books, and Raspberry Pi, and others.)  Languages will claim similar, but C is the veteran in the room that does not bend an allegiance to propriety--C#, Objective-C, etc. C is the go-to foundation for real engineers developing new technology, making it ubiquitous within many tools you use today.  You will find that most languages are merely built from C.  (Therefore, pity the fool who says it cannot be done in C!)  Why limit yourself by higher languages?  Micro-managing code to optimize algorithms makes C binaries the fastest <i>practical</i> processes [<a href="https://benchmarksgame.alioth.debian.org/u64q/which-programs-are-fastest.html">benchmark link</a>].  Being just a step above Assembly, it is expressive as a high level language, while having the ability to cater to the hardware.  The real power goes to those with the faculties to master its domain, as you are made responsible for the binary you produce; the training wheels are off, and there is no safety net!  (<i>Not true anymore, the OS has many built-in fail-safes.</i>)  There are no cutting corners, C comes with minimal tools.  It is the master language, and demands thoroughness.  Use it wisely. </p>
  <p>
    If you can C, everything else is cheese.
  </p>
  </details>

  <br />
  <br />
  
  <details>
    <summary><b>Suggestions :</b></summary>
  
  <p>
    If this is your first rodeo, you will likely be bored by C, thinking "that's all?"  It's a rough starting point.  Best to start with a higher level language to get flashier results sooner; these languages serve a great economical purpose.  Unless you are a person who already enjoys boring subjects like mathematics, biology, or chemistry, then you've found another home in computer science with C!
  </p>
    </details>
  <br />
  <br />
  
  <details>
  <summary><b>Terms you may learn :</b></summary>
  
(but not all necessary for fun)
  <ul>
    <li>libc (by GNU, Musl, or Bionic..), ANSI-C </li>
<li>Pre-Processor, Linker, Assembler, Shared-Object, Makefile </li>
<li>GCC, LLVM/Clang, toolchain </li>
<li>Cygwin, ncurses </li>
<li>GPGPU or OpenGL / OpenCL / Cuda, OpenACC or OpenMP or OpenMPP </li>
<li>APU/FPU (IEEE 754) </li>
<li>BLAS, LAPACK, GMP / GNU MPFR </li>
<li>ASCII, UTF / Unicode, Two's Compliment, Big-Endian / Little-Endian </li>
<li>(Big) O-Notation, P vs NP, Algorithms </li>
<li>Cache, Register, Stack, Heap, Data Structures </li>
<li>Socket, TCP, pthread, Atomic, kernel, urandom / entropy, POSIX </li>
<li>SIGINT, SIGKILL </li>
<li>Race condition, SEI CERT (secure coding) </li>
<li>Segment Fault </li>
  </ul>
  </details>

</body>
</html>
